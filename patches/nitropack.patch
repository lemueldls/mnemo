diff --git a/dist/presets/cloudflare/runtime/cloudflare-durable.mjs b/dist/presets/cloudflare/runtime/cloudflare-durable.mjs
index daaf8185b9a086dfd0eb0edf17768cce45392582..d53177fe9911ca4a5648487338d43a85370cae56 100644
--- a/dist/presets/cloudflare/runtime/cloudflare-durable.mjs
+++ b/dist/presets/cloudflare/runtime/cloudflare-durable.mjs
@@ -1,12 +1,15 @@
 import "#nitro-internal-pollyfills";
 import { DurableObject } from "cloudflare:workers";
-import wsAdapter from "crossws/adapters/cloudflare-durable";
-import { useNitroApp } from "nitropack/runtime";
+import wsAdapter from "crossws/adapters/cloudflare";
+import { useNitroApp } from "nitro/runtime";
 import { isPublicAssetURL } from "#nitro-internal-virtual/public-assets";
-import { createHandler, fetchHandler } from "./_module-handler.mjs";
+import { createHandler, fetchHandler } from "./_module-handler";
+
 const DURABLE_BINDING = "$DurableObject";
 const DURABLE_INSTANCE = "server";
+
 const nitroApp = useNitroApp();
+
 const getDurableStub = (env) => {
   const binding = env[DURABLE_BINDING];
   if (!binding) {
@@ -17,60 +20,85 @@ const getDurableStub = (env) => {
   const id = binding.idFromName(DURABLE_INSTANCE);
   return binding.get(id);
 };
-const ws = import.meta._websocket ? wsAdapter({
-  ...nitroApp.h3App.websocket,
-  instanceName: DURABLE_INSTANCE,
-  bindingName: DURABLE_BINDING
-}) : void 0;
-export default createHandler({
+
+const ws = import.meta._websocket
+  ? wsAdapter({
+      // TODO!
+      // ...nitroApp.h3App.websocket,
+      instanceName: DURABLE_INSTANCE,
+      bindingName: DURABLE_BINDING,
+    })
+  : undefined;
+
+export default createHandler<Env>({
   fetch(request, env, context, url, ctxExt) {
+    // Static assets fallback (optional binding)
     if (env.ASSETS && isPublicAssetURL(url.pathname)) {
       return env.ASSETS.fetch(request);
     }
+
+    // Expose stub fetch to the context
     ctxExt.durableFetch = (req = request) => getDurableStub(env).fetch(req);
-    if (import.meta._websocket && request.headers.get("upgrade") === "websocket") {
+
+    // Websocket upgrade
+    // https://crossws.unjs.io/adapters/cloudflare#durable-objects
+    if (
+      import.meta._websocket &&
+      request.headers.get("upgrade") === "websocket"
+    ) {
       return ws.handleUpgrade(request, env, context);
     }
-  }
+  },
 });
+
 export class $DurableObject extends DurableObject {
   constructor(state, env) {
     super(state, env);
+
     state.waitUntil(
       nitroApp.hooks.callHook("cloudflare:durable:init", this, {
         state,
-        env
+        env,
       })
     );
+
     if (import.meta._websocket) {
       ws.handleDurableInit(this, state, env);
     }
   }
+
+  async getContextValue() {
+    return this.context;
+  }
+
   fetch(request) {
-    if (import.meta._websocket && request.headers.get("upgrade") === "websocket") {
+    if (
+      import.meta._websocket &&
+      request.headers.get("upgrade") === "websocket"
+    ) {
       return ws.handleDurableUpgrade(this, request);
     }
+
+    // Main handler
     const url = new URL(request.url);
+
     return fetchHandler(request, this.env, this.ctx, url, nitroApp, {
-      durable: this
+      durable: this,
     });
   }
-  publish(topic, data, opts) {
-    if (!ws) {
-      throw new Error("WebSocket not available");
-    }
-    return ws.publish(topic, data, opts);
-  }
+
   alarm() {
     this.ctx.waitUntil(
       nitroApp.hooks.callHook("cloudflare:durable:alarm", this)
     );
   }
+
   async webSocketMessage(client, message) {
     if (import.meta._websocket) {
       return ws.handleDurableMessage(this, client, message);
     }
   }
+
   async webSocketClose(client, code, reason, wasClean) {
     if (import.meta._websocket) {
       return ws.handleDurableClose(this, client, code, reason, wasClean);
