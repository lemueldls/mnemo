diff --git a/dist/adapters/cloudflare.mjs b/dist/adapters/cloudflare.mjs
index 402eb25cbe1a5f23af06a89ec2b78579278f1c7a..b48b572aaa5efc1d833adf8b0d5ba8c8174e430b 100644
--- a/dist/adapters/cloudflare.mjs
+++ b/dist/adapters/cloudflare.mjs
@@ -1,226 +1,230 @@
-import { env } from 'cloudflare:workers';
-import { M as Message, P as Peer, t as toBufferLike } from '../shared/crossws.WpyOHUXc.mjs';
-import { a as adapterUtils, g as getPeers, A as AdapterHookable } from '../shared/crossws.CPlNx7g8.mjs';
-import { S as StubRequest } from '../shared/crossws.B31KJMcF.mjs';
-import { W as WSError } from '../shared/crossws.By9qWDAI.mjs';
+import { env as cfGlobalEnv } from "cloudflare:workers";
+import { toBufferLike } from "../utils.ts";
+import { adapterUtils, getPeers } from "../adapter.ts";
+import { AdapterHookable } from "../hooks.ts";
+import { Message } from "../message.ts";
+import { Peer } from "../peer.ts";
+import { StubRequest } from "../_request.ts";
+import { WSError } from "../error.ts";
 
+// https://developers.cloudflare.com/durable-objects/examples/websocket-hibernation-server/
 const cloudflareAdapter = (opts = {}) => {
-  const hooks = new AdapterHookable(opts);
-  const globalPeers = /* @__PURE__ */ new Map();
-  const resolveDurableStub = opts.resolveDurableStub || ((_req, env$1, _context) => {
-    const bindingName = opts.bindingName || "$DurableObject";
-    const binding = (env$1 || env)[bindingName];
-    if (binding) {
-      const instanceId = binding.idFromName(opts.instanceName || "crossws");
-      return binding.get(instanceId);
-    }
-  });
-  const { publish: durablePublish, ...utils } = adapterUtils(globalPeers);
-  return {
-    ...utils,
-    handleUpgrade: async (request, cfEnv, cfCtx) => {
-      const stub = await resolveDurableStub(
-        request,
-        cfEnv,
-        cfCtx
-      );
-      if (stub) {
-        return stub.fetch(
-          request
-        );
-      }
-      const { upgradeHeaders, endResponse, context, namespace } = await hooks.upgrade(request);
-      if (endResponse) {
-        return endResponse;
-      }
-      const peers = getPeers(
-        globalPeers,
-        namespace
-      );
-      const pair = new WebSocketPair();
-      const client = pair[0];
-      const server = pair[1];
-      const peer = new CloudflareFallbackPeer({
-        ws: client,
-        peers,
-        wsServer: server,
-        request,
-        cfEnv,
-        cfCtx,
-        context,
-        namespace
-      });
-      peers.add(peer);
-      server.accept();
-      hooks.callHook("open", peer);
-      server.addEventListener("message", (event) => {
-        hooks.callHook(
-          "message",
-          peer,
-          new Message(event.data, peer, event)
-        );
-      });
-      server.addEventListener("error", (event) => {
-        peers.delete(peer);
-        hooks.callHook("error", peer, new WSError(event.error));
-      });
-      server.addEventListener("close", (event) => {
-        peers.delete(peer);
-        hooks.callHook("close", peer, event);
-      });
-      return new Response(null, {
-        status: 101,
-        webSocket: client,
-        headers: upgradeHeaders
-      });
-    },
-    handleDurableInit: async (obj, state, env) => {
-    },
-    handleDurableUpgrade: async (obj, request) => {
-      const { upgradeHeaders, endResponse, namespace } = await hooks.upgrade(
-        request
-      );
-      if (endResponse) {
-        return endResponse;
-      }
-      const peers = getPeers(globalPeers, namespace);
-      const pair = new WebSocketPair();
-      const client = pair[0];
-      const server = pair[1];
-      const peer = CloudflareDurablePeer._restore(
-        obj,
-        server,
-        request,
-        namespace
-      );
-      peers.add(peer);
-      obj.ctx.acceptWebSocket(server);
-      await hooks.callHook("open", peer);
-      return new Response(null, {
-        status: 101,
-        webSocket: client,
-        headers: upgradeHeaders
-      });
-    },
-    handleDurableMessage: async (obj, ws, message) => {
-      const peer = CloudflareDurablePeer._restore(obj, ws);
-      await hooks.callHook("message", peer, new Message(message, peer));
-    },
-    handleDurableClose: async (obj, ws, code, reason, wasClean) => {
-      const peer = CloudflareDurablePeer._restore(obj, ws);
-      const peers = getPeers(globalPeers, peer.namespace);
-      peers.delete(peer);
-      const details = { code, reason, wasClean };
-      await hooks.callHook("close", peer, details);
-    },
-    handleDurablePublish: async (_obj, topic, data, opts2) => {
-      return durablePublish(topic, data, opts2);
-    },
-    publish: async (topic, data, opts2) => {
-      const stub = await resolveDurableStub(void 0, env, void 0);
-      if (!stub) {
-        throw new Error("[crossws] Durable Object binding cannot be resolved.");
-      }
-      try {
-        return await stub.webSocketPublish(topic, data, opts2);
-      } catch (error) {
-        console.error(error);
-        throw error;
-      }
-    }
-  };
+    const hooks = new AdapterHookable(opts);
+    const globalPeers = new Map();
+    const resolveDurableStub = opts.resolveDurableStub ||
+        ((_req, env, _context) => {
+            const bindingName = opts.bindingName || "$DurableObject";
+            const binding = (env || cfGlobalEnv)[bindingName];
+            if (binding) {
+                const instanceId = binding.idFromName(opts.instanceName || "crossws");
+                return binding.get(instanceId);
+            }
+        });
+    const { publish: durablePublish, ...utils } = adapterUtils(globalPeers);
+    return {
+        ...utils,
+        handleUpgrade: async (request, cfEnv, cfCtx) => {
+            // Upgrade request with Durable Object binding
+            const stub = await resolveDurableStub(request, cfEnv, cfCtx);
+            if (stub) {
+                return stub.fetch(request);
+            }
+            // [Fallback] Upgrade request in same Worker
+            const { upgradeHeaders, endResponse, context, namespace } = await hooks.upgrade(request);
+            if (endResponse) {
+                return endResponse;
+            }
+            const peers = getPeers(globalPeers, namespace);
+            const pair = new WebSocketPair();
+            const client = pair[0];
+            const server = pair[1];
+            const peer = new CloudflareFallbackPeer({
+                ws: client,
+                peers,
+                wsServer: server,
+                request: request,
+                cfEnv,
+                cfCtx,
+                context,
+                namespace,
+            });
+            peers.add(peer);
+            server.accept();
+            hooks.callHook("open", peer);
+            server.addEventListener("message", (event) => {
+                hooks.callHook("message", peer, new Message(event.data, peer, event));
+            });
+            server.addEventListener("error", (event) => {
+                peers.delete(peer);
+                hooks.callHook("error", peer, new WSError(event.error));
+            });
+            server.addEventListener("close", (event) => {
+                peers.delete(peer);
+                hooks.callHook("close", peer, event);
+            });
+            // eslint-disable-next-line unicorn/no-null
+            return new Response(null, {
+                status: 101,
+                webSocket: client,
+                headers: upgradeHeaders,
+            });
+        },
+        handleDurableInit: async (obj, state, env) => {
+            state.blockConcurrencyWhile(async () => {
+                // obj.context = (await state.storage.get("context")) || {};
+                // obj.clearDo = async () => {
+                //   await state.storage.deleteAlarm();
+                //   await state.storage.deleteAll();
+                // };
+            });
+        },
+        handleDurableUpgrade: async (obj, request) => {
+            const { upgradeHeaders, endResponse, context, namespace } = await hooks.upgrade(request);
+            if (endResponse) {
+                return endResponse;
+            }
+            await obj.ctx.storage.put("context", context);
+            const peers = getPeers(globalPeers, namespace);
+            const pair = new WebSocketPair();
+            const client = pair[0];
+            const server = pair[1];
+            const peer = CloudflareDurablePeer._restore(obj, server, context, request, namespace);
+            peers.add(peer);
+            obj.ctx.acceptWebSocket(server);
+            await hooks.callHook("open", peer);
+            // eslint-disable-next-line unicorn/no-null
+            return new Response(null, {
+                status: 101,
+                webSocket: client,
+                headers: upgradeHeaders,
+            });
+        },
+        handleDurableMessage: async (obj, ws, message) => {
+            const context = (await obj.ctx.storage.get("context")) || {};
+            const peer = CloudflareDurablePeer._restore(obj, ws, context);
+            await hooks.callHook("message", peer, new Message(message, peer));
+        },
+        handleDurableClose: async (obj, ws, code, reason, wasClean) => {
+            const context = (await obj.ctx.storage.get("context")) || {};
+            const peer = CloudflareDurablePeer._restore(obj, ws, context);
+            const peers = getPeers(globalPeers, peer.namespace);
+            peers.delete(peer);
+            const details = { code, reason, wasClean };
+            await hooks.callHook("close", peer, details);
+            await obj.ctx.storage.deleteAlarm();
+            await obj.ctx.storage.deleteAll();
+        },
+        handleDurablePublish: async (_obj, topic, data, opts) => {
+            return durablePublish(topic, data, opts);
+        },
+        publish: async (topic, data, opts) => {
+            const stub = await resolveDurableStub(undefined, cfGlobalEnv, undefined);
+            if (!stub) {
+                throw new Error("[crossws] Durable Object binding cannot be resolved.");
+            }
+            // - Compatibility date >= 2024-04-03 or "rpc" feature flag is required
+            // - We cannot check if webSocketPublish is exposed or not without RPC call
+            try {
+                return await stub.webSocketPublish(topic, data, opts);
+            }
+            catch (error) {
+                console.error(error);
+                throw error;
+            }
+        },
+    };
 };
+export default cloudflareAdapter;
+
+// --- peer ---
+
 class CloudflareDurablePeer extends Peer {
-  get peers() {
-    return new Set(
-      this.#getwebsockets().map(
-        (ws) => CloudflareDurablePeer._restore(this._internal.durable, ws)
-      )
-    );
-  }
-  #getwebsockets() {
-    return this._internal.durable.ctx.getWebSockets();
-  }
-  send(data) {
-    return this._internal.ws.send(toBufferLike(data));
-  }
-  subscribe(topic) {
-    super.subscribe(topic);
-    const state = getAttachedState(this._internal.ws);
-    if (!state.t) {
-      state.t = /* @__PURE__ */ new Set();
+    get peers() {
+        return new Set(this.#getwebsockets().map((ws) => CloudflareDurablePeer._restore(this._internal.durable, ws, this._internal.context)));
+    }
+    #getwebsockets() {
+        return this._internal.durable.ctx.getWebSockets();
     }
-    state.t.add(topic);
-    setAttachedState(this._internal.ws, state);
-  }
-  publish(topic, data) {
-    const websockets = this.#getwebsockets();
-    if (websockets.length < 2) {
-      return;
+    send(data) {
+        return this._internal.ws.send(toBufferLike(data));
     }
-    const dataBuff = toBufferLike(data);
-    for (const ws of websockets) {
-      if (ws === this._internal.ws) {
-        continue;
-      }
-      const state = getAttachedState(ws);
-      if (state.t?.has(topic)) {
-        ws.send(dataBuff);
-      }
+    subscribe(topic) {
+        super.subscribe(topic);
+        const state = getAttachedState(this._internal.ws);
+        if (!state.t) {
+            state.t = new Set();
+        }
+        state.t.add(topic);
+        setAttachedState(this._internal.ws, state);
     }
-  }
-  close(code, reason) {
-    this._internal.ws.close(code, reason);
-  }
-  static _restore(durable, ws, request, namespace) {
-    let peer = ws._crosswsPeer;
-    if (peer) {
-      return peer;
+    publish(topic, data) {
+        const websockets = this.#getwebsockets();
+        if (websockets.length < 2 /* 1 is self! */) {
+            return;
+        }
+        const dataBuff = toBufferLike(data);
+        for (const ws of websockets) {
+            if (ws === this._internal.ws) {
+                continue;
+            }
+            const state = getAttachedState(ws);
+            if (state.t?.has(topic)) {
+                ws.send(dataBuff);
+            }
+        }
     }
-    const state = ws.deserializeAttachment() || {};
-    peer = ws._crosswsPeer = new CloudflareDurablePeer({
-      ws,
-      request: request || new StubRequest(state.u || ""),
-      namespace: namespace || state.n || "",
-      durable
-    });
-    if (state.i) {
-      peer._id = state.i;
+    close(code, reason) {
+        this._internal.ws.close(code, reason);
     }
-    if (request?.url) {
-      state.u = request.url;
+    static _restore(durable, ws, context, request, namespace) {
+        let peer = ws._crosswsPeer;
+        if (peer) {
+            return peer;
+        }
+        const state = (ws.deserializeAttachment() || {});
+        peer = ws._crosswsPeer = new CloudflareDurablePeer({
+            ws: ws,
+            context,
+            request: request || new StubRequest(state.u || ""),
+            namespace: namespace || state.n || "" /* later throws error if empty */,
+            durable: durable,
+        });
+        if (state.i) {
+            peer._id = state.i;
+        }
+        if (request?.url) {
+            state.u = request.url;
+        }
+        state.i = peer.id;
+        setAttachedState(ws, state);
+        return peer;
     }
-    state.i = peer.id;
-    setAttachedState(ws, state);
-    return peer;
-  }
 }
 class CloudflareFallbackPeer extends Peer {
-  send(data) {
-    this._internal.wsServer.send(toBufferLike(data));
-    return 0;
-  }
-  publish(_topic, _message) {
-    console.warn(
-      "[crossws] [cloudflare] pub/sub support requires Durable Objects."
-    );
-  }
-  close(code, reason) {
-    this._internal.ws.close(code, reason);
-  }
+    send(data) {
+        this._internal.wsServer.send(toBufferLike(data));
+        return 0;
+    }
+    publish(_topic, _message) {
+        console.warn("[crossws] [cloudflare] pub/sub support requires Durable Objects.");
+    }
+    close(code, reason) {
+        this._internal.ws.close(code, reason);
+    }
 }
+
+// -- attached state utils ---
+
 function getAttachedState(ws) {
-  let state = ws._crosswsState;
-  if (state) {
+    let state = ws._crosswsState;
+    if (state) {
+        return state;
+    }
+    state = ws.deserializeAttachment() || {};
+    ws._crosswsState = state;
     return state;
-  }
-  state = ws.deserializeAttachment() || {};
-  ws._crosswsState = state;
-  return state;
 }
 function setAttachedState(ws, state) {
-  ws._crosswsState = state;
-  ws.serializeAttachment(state);
+    ws._crosswsState = state;
+    ws.serializeAttachment(state);
 }
-
-export { cloudflareAdapter as default };
